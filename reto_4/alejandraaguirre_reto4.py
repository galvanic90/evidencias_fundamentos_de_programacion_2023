# -*- coding: utf-8 -*-
"""AlejandraAguirre_Reto4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fK8cpIZfF21EGoc3iJXB21WP9ICwX_Lp

El código proporcionado para el Reto 3 no sigue estrictamente el paradigma funcional, ya que utiliza un enfoque imperativo en la gestión de menús y variables globales. Aquí se presentan las falencias y las áreas donde se podría aplicar el paradigma funcional de manera más coherente:

Falencias:

Uso de Variables Globales: El código utiliza variables globales para almacenar datos como los costos y la producción. En el paradigma funcional, se prefieren las funciones puras que toman entradas y devuelven resultados sin depender de variables globales.

Ciclo Infinito: El ciclo infinito while True se utiliza para mantener la aplicación en ejecución, pero no es una práctica común en el paradigma funcional. En su lugar, se pueden utilizar funciones recursivas o estructuras de datos más apropiadas.

Uso de Entrada de Usuario: El código utiliza la entrada de usuario mediante input() directamente en funciones, lo que dificulta la prueba y el aislamiento de funciones.

Sugerencias para Aplicar el Paradigma Funcional:

Evitar Variables Globales: En lugar de utilizar variables globales para almacenar datos, se pueden pasar como argumentos a las funciones que los necesiten. Por ejemplo, los costos y la producción pueden ser argumentos de funciones específicas.

Funciones Puras: Se deben diseñar funciones que sean puras, es decir, que no tengan efectos secundarios y produzcan resultados basados únicamente en sus entradas. Esto facilita la prueba y la comprensión del código.

Evitar Ciclos Infinitos: En lugar de un ciclo infinito, se pueden diseñar funciones principales que llamen a otras funciones según sea necesario. Por ejemplo, una función principal que maneje la aplicación y llame a funciones de gestión de cultivos y funciones de contabilidad según las elecciones del usuario.

Manejo de Entrada de Usuario: Se pueden utilizar funciones para solicitar y procesar la entrada del usuario. Esto puede ayudar a mejorar la modularidad y la legibilidad del código.

Recursión: Cuando sea necesario realizar llamadas repetitivas, considerar el uso de la recursión en lugar de ciclos infinitos para mantener la aplicación en ejecución.

Inmutabilidad: En la medida de lo posible, se debe evitar la mutabilidad de los datos y utilizar estructuras de datos inmutables para representar información.

Desacoplar la Lógica: Separar la lógica de la interfaz de usuario. Esto facilita las pruebas y permite cambiar la interfaz sin afectar la lógica subyacente.

En resumen, para aplicar el paradigma funcional de manera más coherente, se deben refactorizar las funciones, reducir la dependencia de variables globales y aplicar principios de programación funcional como la inmutabilidad y la pureza de las funciones. Esto hará que el código sea más modular y mantenible.
"""

import math

def main():
    print("Calculadora Científica")
    while True:
        print("\nOperaciones disponibles:")
        print("1. Operaciones aritméticas básicas")
        print("2. Operaciones aritméticas extendidas")
        print("3. Operaciones trigonométricas")
        print("4. Operaciones estadísticas básicas")
        print("5. Salir")

        opcion = input("Elija una opción: ")

        if opcion == "1":
            operaciones_aritmeticas_basicas()
        elif opcion == "2":
            operaciones_aritmeticas_extendidas()
        elif opcion == "3":
            operaciones_trigonometricas()
        elif opcion == "4":
            operaciones_estadisticas()
        elif opcion == "5":
            print("¡Hasta luego!")
            break
        else:
            print("Opción no válida. Por favor, elija una opción válida.")

def operaciones_aritmeticas_basicas():
    print("\nOperaciones aritméticas básicas:")
    numero1 = float(input("Ingrese el primer número: "))
    numero2 = float(input("Ingrese el segundo número: "))

    print("Resultado:")
    print("Suma:", numero1 + numero2)
    print("Resta:", numero1 - numero2)
    print("Multiplicación:", numero1 * numero2)

    if numero2 != 0:
        print("División:", numero1 / numero2)
    else:
        print("No se puede dividir por cero.")

def operaciones_aritmeticas_extendidas():
    print("\nOperaciones aritméticas extendidas:")
    numero = float(input("Ingrese un número: "))

    print("Resultado:")
    print("División entera:", numero // 2)
    print("Residuo:", numero % 2)
    n = int(input("Ingrese el valor de n para la exponenciación: "))
    print("Exponenciación a la n:", numero ** n)

    if numero >= 0:
        print("Raíz cuadrada:", math.sqrt(numero))

    print("Logaritmo en base 10:", math.log10(numero))
    print("Logaritmo natural:", math.log(numero))
    print("Valor absoluto:", abs(numero))
    if numero != 0:
        print("1/número:", 1 / numero)
    else:
        print("No se puede calcular 1/número para cero.")

    print("Factorial:", math.factorial(int(numero)))

def operaciones_trigonometricas():
    print("\nOperaciones trigonométricas:")
    angulo = float(input("Ingrese un ángulo en grados: "))
    radianes = math.radians(angulo)

    print("Resultado:")
    print("Seno:", math.sin(radianes))
    print("Coseno:", math.cos(radianes))
    print("Tangente:", math.tan(radianes))

def operaciones_estadisticas():
    print("\nOperaciones estadísticas básicas:")
    n = int(input("Ingrese la cantidad de números: "))
    numeros = []

    for i in range(n):
        numero = float(input(f"Ingrese el número {i + 1}: "))
        numeros.append(numero)

    print("Resultado:")
    print("Promedio:", sum(numeros) / n)
    print("Media:", max(numeros))
    print("Mediana:", sorted(numeros)[n // 2])
    moda = max(set(numeros), key=numeros.count)
    print("Moda:", moda)

if __name__ == "__main__":
    main()